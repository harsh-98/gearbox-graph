# CreditRegister and pools
type ContractsRegister @entity {
  id: ID!
}
type AddressProvider @entity {
    id: ID!
}
type Pool @entity {
  id: ID!
  expectedLiquidityLimit: BigInt
  liquidity: BigInt
  borrowForbidden: [Bytes!]
  creditManagers: [CreditManager!] @derivedFrom(field: "pool")
}
type CreditManager @entity {
  id: ID!
  pool: Pool
  minAmount: BigInt
  maxAmount: BigInt
  maxLeverage: BigInt
  feeSuccess: BigInt
  feeInterest: BigInt
  feeLiquidation: BigInt
  liquidationDiscount: BigInt
}

# CreditAccounts
type AccountFactory @entity {
  id: ID!
  address: Bytes! # address
}

type CreditAccountMap @entity {
  id: ID!
  creditAccount: Bytes!
}
type CreditAccountIndex @entity {
  id: ID!
  index: BigInt!
}

type CreditAccount @entity {
  id: ID!
  account: Bytes! # address
  owner: Bytes! # address
  creditManager: CreditManager

  openBlock: BigInt
  openHash: Bytes
  closeBlock: BigInt
  closeHash: Bytes

  collateral: BigInt
  borrowAmount: BigInt
  # on close
  withDrawnTo: Bytes
  remainingFund: BigInt
  # liquidate
  liquidator: Bytes
}

#type Liquidate @entity {
  #id: ID!
  #account: CreditAccount!
  #remainingFund: BigInt!
  #liquidator: Bytes!
  #liqBlock: BigInt
  #liqHash: Bytes
#}

#type UserPoolAction @entity {
  #id: ID!
  #user: Bytes! 
  #pool: Pool!
  #Liquidity: BigInt
#}

#type CreditAccountAndManagerBorrow @entity {
  #id: ID!
  #creditAccount: CreditAccount!
  #creditManager: CreditManager!
  #borrowedAmount: BigInt
  #profit: BigInt 
  #loss: BigInt
#}